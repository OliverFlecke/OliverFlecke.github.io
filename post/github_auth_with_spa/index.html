<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>Authenticate with Github on a Single-Page Application | OliverFlecke</title>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Oliver Fleckenstein">
<meta name=description content="Blog, notes and everything else for Oliver Fleckenstein">
<meta name=keywords content="development,notes">
<link href=/css/main.css rel=stylesheet>
<meta name=robots content="follow">
<meta name=color-scheme content="dark light">
<meta name=theme-color content="#4C1D95">
<script async defer data-api=https://plausible.oliverflecke.me/api/event data-domain=oliverflecke.me src=https://plausible.oliverflecke.me/js/script.js></script>
</head>
<body class="bg-coolGray-100 dark:bg-gray-900 min-h-screen flex flex-col">
<header class="p-6 bg-purple-900 flex justify-center">
<div class="w-full max-w-2xl">
<nav class="flex items-center justify-between flex-wrap pb-4">
<div class="block lg:hidden">
<button onclick="document.getElementById('nav-items')?.classList.toggle('hidden')" class="flex items-center px-3 py-2 border rounded text-teal-200 border-teal-400 hover:text-white hover:border-white"><svg class="fill-current h-3 w-3" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><title>Menu</title><path d="M0 3h20v2H0V3zm0 6h20v2H0V9zm0 6h20v2H0v-2z"/></svg>
</button>
</div>
<div class="flex items-center flex-shrink-0 text-white">
<a href=/ class=pr-4>Oliver Fleckenstein</a>
<div class="flex space-x-3">
<a href=https://github.com/oliverflecke>
<img src=/icons/github.svg alt="GitHub logo with link to OliverFlecke's profile" width=2rem height=2rem class=w-8>
</a>
<a href=https://linkedin.com/in/oliverflecke/>
<img src=/icons/linkedin.svg alt="LinkedIn logo with link to OliverFlecke's profile" width=2rem height=2rem class=w-8>
</a>
</div>
</div>
<ul id=nav-items class="w-full hidden flex-grow pt-4 lg:pt-0 lg:w-auto lg:flex lg:justify-end lg:space-x-8 uppercase text-xl text-gray-100">
<li><a class=nav-link href=/>Home</a></li>
<li><a class=nav-link href=/about>About</a></li>
<li><a class=nav-link href=/about#experience>Experience</a></li>
<li><a class=nav-link href=/post>Posts</a></li>
</ul>
</nav>
</div>
</header>
<main class="flex-grow h-full w-screen pb-4 flex flex-col items-center">
<section class="text-gray-900 dark:text-gray-300">
<h2 class="text-2xl pt-4 text-lime-700 dark:text-lime-600">
<a href=https://oliverflecke.me/post/github_auth_with_spa/>Authenticate with Github on a Single-Page Application</a>
</h2>
<div class=space-x-4>
<time class="text-sm text-purple-700 dark:text-lime-500">2021-08-11</time>
<span class="text-sm italic text-gray-600 dark:text-gray-400">Reading time: 8 minutes</span>
</div>
<div class=markdown>
<h2 id=introduction>Introduction</h2>
<p>For a recent project, I wanted a way to authenticate users, but without all the struggle of managing users and their data.
This was for a frontend, single-page application (SPA) where everything could be served as static HTML/CSS/JS files.
My solution was to allow users to sign in with their Github credentials using OAuth.
This is the best of both worlds: I won&rsquo;t have to store any user data or think much about security, and users don&rsquo;t have to trust me with their email or password.</p>
<p>Github provide <a href=https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#web-application-flow>some good documentation</a> for how to perform this flow from inside a web browser, with one minor issue: <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>Cross-Origin Resource Sharing (CORS)</a>.
Because one of the calls to Github&rsquo;s API does not allow CORS, meaning you cannot call it from outside Github&rsquo;s domain, it is not possible to complete the OAuth flow entirely in the browser.
But <a href=#getting-an-access-token>later</a> we will see a relative simple solution to get around this problem.</p>
<h2 id=tldr>TL;DR</h2>
<p>Link to code: <a href=https://github.com/oliverflecke/github-oauth-proxy>proxy server</a> and frontend application (to be added).</p>
<h2 id=the-authentication-flow>The authentication flow</h2>
<p>First of, an overview of the flow.</p>
<ul>
<li>Starting from our SPA, when the user clicks &lsquo;login&rsquo;, the browser redirects to <code>github.com/login/oauth/authorize</code>. This page will display Github&rsquo;s email/password prompt that external users should be familiar with.</li>
<li>After the user has entered their credentials, the browser redirects back to our website, with a code that our website can exchange for an <code>access token</code>.</li>
<li>Lastly, after having received the access token we can call Github&rsquo;s APIs!</li>
</ul>
<p>Before getting started with coding, we have to register an OAuth application at Github.
Github <a href=https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app>provides a good guide for creating an OAuth App</a>, but all you have to do is visit <a href=https://github.com/settings/developers>https://github.com/settings/developers</a>, click create and enter the app information.</p>
<p>The most important part is the <code>authorization callback url</code> (which can always be changed later), with is the url that the browser will redirect back to after a successful user login.
This also means, that even if others steal your client id and secret, they can redirect users to Github&rsquo;s website and make them login, but the user&rsquo;s browser will always be redirected back to the specified callback url.</p>
<p>Grab the client id and generate a client secret.
This secert should be kept, well, secret, and should therefore not be published with the client code or checked in to source control.
More on that later.</p>
<h2 id=redirecting-to-github-to-request-a-users-identity>Redirecting to Github to request a user&rsquo;s identity</h2>
<p>First step of the process is to redirect the user to Github, which can be done with a simple link to the <code>authorize</code> endpoint.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-html data-lang=html>&lt;<span style=color:#ff79c6>a</span> <span style=color:#50fa7b>href</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;https://github.com/login/oauth/authorize?client_id=&lt;your_client_id&gt;&amp;state=&lt;generated_state&gt;&#34;</span>&gt;
	Login
&lt;/<span style=color:#ff79c6>a</span>&gt;
</code></pre></div><p>The <code>your_client_id</code> is the one we created in the previous step, and can safely be added here.
<code>generated_state</code> is an <strong>unguessable random string</strong> which is used to protect agains cross-site request forgery attacks.</p>
<p>There are <a href=https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps#parameters>other paramters</a> that can be provided, such as the <code>redirect_url</code> but leaving this out will redirect the browser to the one we provided to Github when creating the OAuth application.
Another usefull one is the <a href=https://docs.github.com/en/apps/building-oauth-apps/understanding-scopes-for-oauth-apps>scopes</a>, which allow you to request access to different parts of Github&rsquo;s API.
However, as I&rsquo;m only after getting the user&rsquo;s identity, we can leave this empty and it will only allow us to access public information.</p>
<h2 id=getting-an-access-token>Getting an access token</h2>
<p>After the user has logged in, the browser is redirected back to you site (by the provided callback url).
Passed as query parameters is a <code>code</code> and <code>state</code> value.
The <code>state</code> <strong>must</strong> be the same value as we provided when redirecting the user to Github in the first step - if not, we must abort the flow.
The <code>code</code> is prof of the user&rsquo;s identity, and can be exchanged within the next 10 minutes for an access token.</p>
<p>A simple way to get and check the <code>code</code> and <code>state</code> is to use <a href=https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams><code>URLSearchParams</code></a>.
Passing it <code>window.location.search</code> will make it parse the query parameters and give you a simple object to retreive the values from.
Below is a code snippet to parse and verify that <code>code</code> and <code>state</code> is in the query string and that the <code>state</code> matches the expected state.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js><span style=color:#ff79c6>const</span> params <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> URLSearchParams(<span style=color:#8be9fd;font-style:italic>window</span>.location.search);
<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>params.has(<span style=color:#f1fa8c>&#39;code&#39;</span>)) {
	<span style=color:#ff79c6>return</span>;
}

<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>params.has(<span style=color:#f1fa8c>&#39;state&#39;</span>) <span style=color:#ff79c6>||</span> params.get(<span style=color:#f1fa8c>&#39;state&#39;</span>) <span style=color:#ff79c6>!==</span> expectedState) {
	<span style=color:#ff79c6>return</span>;
}

<span style=color:#ff79c6>const</span> code <span style=color:#ff79c6>=</span> params.get(<span style=color:#f1fa8c>&#39;code&#39;</span>);
</code></pre></div><p>Next we can exchange the <code>code</code> for an <code>access token</code>.
This is done by the following HTTP POST call, which can be done with JavaScript&rsquo;s <code>fetch</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>fetch(<span style=color:#f1fa8c>&#39;https://github.com/login/oauth/access_token/&#39;</span>, {
	method<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;POST&#39;</span>,
	headers<span style=color:#ff79c6>:</span> {
		Accept<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
		<span style=color:#f1fa8c>&#39;Content-Type&#39;</span><span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
	},
	body<span style=color:#ff79c6>:</span> JSON.stringify({
		code,
		client_id,
		client_secret,
	}),
})
</code></pre></div><p>However, when running this inside a browser, we get an error.
Looking in the network tab we see:</p>
<p><img src=/media/github-auth-cors.png alt="Screenshot of network tab in browser showing a CORS error"></p>
<p>Github`s OAuth endpoints <a href=https://github.com/isaacs/github/issues/330>does not currently support browser-only flows</a>, as it is required to provide a client secret.
Secrets can inherently not be trusted if sent to the client, so we must proxy requests to the token endpoint through our own, trusted server.</p>
<p>Below is a small NodeJS server using <a href=https://expressjs.com/>express</a> to provide an endpoint to which we can proxy our requests (the full source code can be found <a href=https://github.com/oliverflecke/github-oauth-proxy>on Github in this repository</a>).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js><span style=color:#ff79c6>const</span> fetch <span style=color:#ff79c6>=</span> require(<span style=color:#f1fa8c>&#39;node-fetch&#39;</span>);
<span style=color:#ff79c6>const</span> express <span style=color:#ff79c6>=</span> require(<span style=color:#f1fa8c>&#39;express&#39;</span>);
<span style=color:#ff79c6>const</span> cors <span style=color:#ff79c6>=</span> require(<span style=color:#f1fa8c>&#39;cors&#39;</span>);

require(<span style=color:#f1fa8c>&#39;dotenv&#39;</span>).config();
<span style=color:#ff79c6>const</span> port <span style=color:#ff79c6>=</span> process.env.PORT <span style=color:#ff79c6>||</span> <span style=color:#bd93f9>80</span>;
<span style=color:#ff79c6>const</span> client_id <span style=color:#ff79c6>=</span> process.env.CLIENT_ID;
<span style=color:#ff79c6>const</span> client_secret <span style=color:#ff79c6>=</span> process.env.CLIENT_SECRET;

<span style=color:#ff79c6>const</span> app <span style=color:#ff79c6>=</span> express();

app.use(cors({
	origin<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;https://example.com&#39;</span>,
}));

<span style=color:#ff79c6>const</span> GITHUB_AUTH_ACCESSTOKEN_URL <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;https://github.com/login/oauth/access_token/&#39;</span>;

app.post(<span style=color:#f1fa8c>&#39;/authorize&#39;</span>, (req, res) =&gt; {
	<span style=color:#ff79c6>const</span> code <span style=color:#ff79c6>=</span> req.query.code;

	fetch(GITHUB_AUTH_ACCESSTOKEN_URL, {
		method<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;POST&#39;</span>,
		headers<span style=color:#ff79c6>:</span> {
			Accept<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
			<span style=color:#f1fa8c>&#39;Content-Type&#39;</span><span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
		},
		body<span style=color:#ff79c6>:</span> JSON.stringify({
			client_id,
			client_secret,
			code,
		}),
	})
		.then(<span style=color:#ff79c6>async</span> (response) =&gt; {
			<span style=color:#ff79c6>const</span> json <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> response.json();
			<span style=color:#ff79c6>if</span> (<span style=color:#f1fa8c>&#39;error&#39;</span> <span style=color:#ff79c6>in</span> json) {
				res.status(<span style=color:#bd93f9>400</span>).send(json);
			} <span style=color:#ff79c6>else</span> {
				res.send(json);
			}
		})
		.<span style=color:#ff79c6>catch</span>(<span style=color:#8be9fd;font-style:italic>function</span> (error) {
			console.error(<span style=color:#f1fa8c>&#39;Error &#39;</span> <span style=color:#ff79c6>+</span> error.message);
			res.status(<span style=color:#bd93f9>400</span>).send(error.message);
		});
});

app.get(<span style=color:#f1fa8c>&#39;/&#39;</span>, <span style=color:#8be9fd;font-style:italic>function</span> (req, res) {
	res.send(<span style=color:#f1fa8c>&#39;OK&#39;</span>);
});

app.listen(port, <span style=color:#8be9fd;font-style:italic>function</span> () {
	console.log(<span style=color:#f1fa8c>&#39;Authorization proxy is running&#39;</span>);
});
</code></pre></div><p>To run this, you will need to install a few dependencies:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>yarn add express cors dotenv node<span style=color:#ff79c6>-</span>fetch
</code></pre></div><h3 id=rundown-of-the-code>Rundown of the code</h3>
<p>Below is a rundown of the server side code, if needed.</p>
<h4 id=configuring-the-server>Configuring the server</h4>
<p>The first few lines simply imports the libraries we need.
The first interisting part is using the <code>dotenv</code> package, which is used to read environment variables from a <code>.env</code> file (primarily used for running the app locally).
As we want to avoid hardcoding secrets into our source code, we can instead save them the <code>.env</code> file and read them when the application starts.
This also allows us to provide the values when running the app on a server.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>require(<span style=color:#f1fa8c>&#39;dotenv&#39;</span>).config();
<span style=color:#ff79c6>const</span> port <span style=color:#ff79c6>=</span> process.env.PORT <span style=color:#ff79c6>||</span> <span style=color:#bd93f9>80</span>;
<span style=color:#ff79c6>const</span> client_id <span style=color:#ff79c6>=</span> process.env.CLIENT_ID;
<span style=color:#ff79c6>const</span> client_secret <span style=color:#ff79c6>=</span> process.env.CLIENT_SECRET;
</code></pre></div><p>The <code>.env</code> file would look something like and be placed in the root of the project directory:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sh data-lang=sh><span style=color:#8be9fd;font-style:italic>CLIENT_ID</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;&lt;your_client_id&gt;&#39;</span>
<span style=color:#8be9fd;font-style:italic>CLIENT_SECRET</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;&lt;your_client_secret&gt;&#39;</span>
<span style=color:#8be9fd;font-style:italic>PORT</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>8000</span>
</code></pre></div><p>Next the app/server that should listen is created, along with adding support for CORS (which is the whole reason we are doing this).
Here you should provide the origin for your own website, which will make it sure it only works your domain.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js><span style=color:#ff79c6>const</span> app <span style=color:#ff79c6>=</span> express();

app.use(cors({
	origin<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;https://example.com&#39;</span>,
}));
</code></pre></div><h4 id=proxying-the-request-to-github>Proxying the request to Github</h4>
<p>To listen for <code>POST</code> requests in express, call <code>app.post</code> and provide it with the url to listen at along with a callback to process the request.
In the code is added an endpoint at <code>/authorize</code> which we will use to proxy the request to Github.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>app.post(<span style=color:#f1fa8c>&#39;/authorize&#39;</span>, (req, res) =&gt; {
	...
}
</code></pre></div><p>Inside the callback, a few things are going on.
First off, we pull the <code>code</code> out of request query</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>	<span style=color:#ff79c6>const</span> code <span style=color:#ff79c6>=</span> req.query.code;
</code></pre></div><p>To match the browser as much as possible, I use <code>node-fetch</code> to perform exactly the same request as we did from the browser.
The code for calling Github&rsquo;s token endpoint therefore looks the same as it did in the browser.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>	fetch(GITHUB_AUTH_ACCESSTOKEN_URL, {
		method<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;POST&#39;</span>,
		headers<span style=color:#ff79c6>:</span> {
			Accept<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
			<span style=color:#f1fa8c>&#39;Content-Type&#39;</span><span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
		},
		body<span style=color:#ff79c6>:</span> JSON.stringify({
			client_id,
			client_secret,
			code,
		}),
	})
</code></pre></div><p>Lastly, we have to send the respond from Github back to the caller.
When the fetch <code>Promise</code> resolves, we can read the json response, check if it contains an error, and otherwise just send it back to the caller (this is done with <code>res.send(json)</code>).
In case of an error in the response or if the fetch call itself fails, the error is also send back to the client.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>		.then(<span style=color:#ff79c6>async</span> (response) =&gt; {
			<span style=color:#ff79c6>const</span> json <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> response.json();
			<span style=color:#ff79c6>if</span> (<span style=color:#f1fa8c>&#39;error&#39;</span> <span style=color:#ff79c6>in</span> json) {
				res.status(<span style=color:#bd93f9>400</span>).send(json);
			} <span style=color:#ff79c6>else</span> {
				res.send(json);
			}
		})
		.<span style=color:#ff79c6>catch</span>(<span style=color:#8be9fd;font-style:italic>function</span> (error) {
			console.error(<span style=color:#f1fa8c>&#39;Error &#39;</span> <span style=color:#ff79c6>+</span> error.message);
			res.status(<span style=color:#bd93f9>400</span>).send(error.message);
		});
</code></pre></div><h4 id=a-small-health-check-and-starting-the-app>A small health check and starting the app</h4>
<p>It is often usefull to have a health check endpoint to verify that the application is running and listening as expected.
The next few lines add this, by listening at the root <code>/</code> and always responding with <code>OK</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>app.get(<span style=color:#f1fa8c>&#39;/&#39;</span>, <span style=color:#8be9fd;font-style:italic>function</span> (req, res) {
	res.send(<span style=color:#f1fa8c>&#39;OK&#39;</span>);
});
</code></pre></div><p>Lastly, we start the application and make it listen to the provided <code>port</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>app.listen(port, <span style=color:#8be9fd;font-style:italic>function</span> () {
	console.log(<span style=color:#f1fa8c>&#39;Authorization proxy is running&#39;</span>);
});
</code></pre></div><h3 id=updating-the-client-code-to-call-the-proxy>Updating the client code to call the proxy</h3>
<p>Now we are ready to use our proxy in our browser application.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>fetch(<span style=color:#f1fa8c>`</span><span style=color:#f1fa8c>${</span>authCors<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>?code=</span><span style=color:#f1fa8c>${</span>code<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>`</span>, {
	method<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;post&#39;</span>,
	headers<span style=color:#ff79c6>:</span> {
		Accept<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;application/json&#39;</span>,
	},
})
	.then(<span style=color:#ff79c6>async</span> (res) =&gt; {
		<span style=color:#ff79c6>if</span> (res.status <span style=color:#ff79c6>===</span> <span style=color:#bd93f9>200</span>) {
			<span style=color:#ff79c6>const</span> body <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> res.json();
		}
		<span style=color:#ff79c6>else</span> {
			console.warn(<span style=color:#f1fa8c>`Got an unexpected status </span><span style=color:#f1fa8c>${</span>res.status<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>`</span>);
		}
	}
</code></pre></div><p>Replace <code>authCors</code> with the URL to the proxy, and the code with the one we got from the callback from Github.
The <code>body</code> returned from the proxy will then look like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json>{
	<span style=color:#ff79c6>&#34;access_token&#34;</span>: <span style=color:#f1fa8c>&#34;FKBa0gzbI1...&#34;</span>,
	<span style=color:#ff79c6>&#34;scopes&#34;</span>: <span style=color:#f1fa8c>&#34;&lt;the scopes you have requested&gt;&#34;</span>,
	<span style=color:#ff79c6>&#34;token_type&#34;</span>: <span style=color:#f1fa8c>&#34;Bearer&#34;</span>
}
</code></pre></div><h3 id=deployment>Deployment</h3>
<p>I like playing around with different tools and platforms to learn how they work and which options are out there.
For this project, I have deployed the proxy server using <a href=https://www.heroku.com/>heroku</a>.
At the time of writing, they allow you to create several lightweight application for you to test out.
Simply sign up for an account, create an app, and go to the deploy tab for instructions to deploy the server directly from git.
Otherwise have a look <a href=https://devcenter.heroku.com/articles/git>here for a full article on how to deploy the code</a>.</p>
<h2 id=getting-the-user-info>Getting the user info</h2>
<p>Now that we have an access token for the authorized user, we can use it to actually call Github&rsquo;s APIs.
The goal for my application was simply to have a way to identify unique users, hence I did not include any scopes in the token request.
To get a user&rsquo;s public information, we can use the <code>/user</code> endpoint.
Below is a code snippet to request the user information from Github.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-js data-lang=js>fetch(<span style=color:#f1fa8c>&#39;https://api.github.com/user&#39;</span>, {
	headers<span style=color:#ff79c6>:</span> {
		Authorization<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>`token </span><span style=color:#f1fa8c>${</span>token<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>`</span>,
	},
})
	.then(<span style=color:#ff79c6>async</span> (res) =&gt; {
		<span style=color:#ff79c6>const</span> user <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> res.json();
		...
	});
</code></pre></div><p>The user object returned contains all the public information for the given user&rsquo;s profile, including Github username, id, email address, and profile picture.</p>
</div>
</section>
</main>
<footer class="w-full p-4 bg-purple-800">
</footer>
</body>
</html>